---
title: k8s閱讀筆記
description: 123
authors: suyuying
image: https://github.com/suyuying.png
tags: [IaC]
draft: true
---

k8s 的教學很多,這邊會列出看過的網站跟重點筆記.

## 基本介紹

### 硬體部分

- 節點 (Node): 是 Kubernetes 中最小的硬體單元，可能是 VM 或者物理機器。

- 集群 (Cluster): 一個集群是由多個節點組成以及 control plane 所組成的，透過 control plane 管理 cluster,nodes 跟 control plane 溝通是透過 k8s api,而 end user 也是透過 k8s api 跟 cluster 做直接互動.

### 軟體部分

- Pod: 是 Kubernetes 中的最小部署(程式)單元，每個 Pod 都包含一個或多個容器。
  將 pod 裡面的 container 保持在最小數量，可以減少資源的浪費，提高效能，並簡化 Pod 的管理.
- 部署 (Deployment): k8s 抽象出 deployment 來管理 pod,用來描述系統怎樣管理 pod,deployment 會依據設定檔做擴展多個 pod 或重啟 pod 等工作.

- 服務 (Service): 是一種抽象化概念，用來描述一組提供同樣功能的 Pod，並且定義了如何訪問這些 Pod.

#### service 間溝通

服務 (Services) 之間的通信主要透過以下幾種方式：

- Service Discovery: Kubernetes 提供了基於 DNS 的服務發現功能。當你創建一個 Service 時，Kubernetes 會在其內部 DNS 伺服器中為該 Service 創建一個相應的 DNS 紀錄。所以，Pods 在同一個 Kubernetes 集群內可以通過該 Service 的名稱進行通信。

- Service IP and Port: 每個 Service 在創建時，都會被分配一個唯一的 IP 地址（也稱為 cluster IP）和端口。Pods 可以通過這個 IP 和端口與 Service 進行通信。但請注意，這個 cluster IP 通常只能在集群內部訪問。

- Environment Variables: Kubernetes 也可以將一個 Service 的資訊（如 IP 地址和端口）注入到 Pod 的環境變量中。這樣，該 Pod 的容器就可以讀取這些環境變量以進行通信。

簡單說,就是像 docker 可以用 container 的名稱,或者 ip 去找其他服務做溝通！

lab

1. 分別示範建立 service,loadbalacer,ingress 等,可以用 deployment 建立,或者用 nginx ingress 方法,把流量直接轉到 service 在到 pod.

- 開啟 cluster

```
minikube start
```

- 開啟一個監管的 dash board

```
 minikube dashboard
```

- 建立 cluster 之後,可以透過 kubectl 指令去跟 cluster 互動,
  最基本,建立 deployment,他負責檢查 pod 健康,如果 pod 掛了會重啟 pod,建議用 deployment 去管理 pods.
  kubectl create deployment hello-minikube --image=kicbase/echo-server:1.0

確認

```
# 看deployment狀態
kubectl get deployments
#看pod狀態
kubectl get pods
#看pod事件
kubectl get events
# 看k8s config
kubectl config view
```

### create a service

因為預設 pod 只有在 cluster 給他的內部 ip,如果要讓它接壤外部,需要透過 k8s 虛擬網路將 k8s 以 service 形式對外呈現.
The --type=LoadBalancer flag indicates that you want to expose your Service outside of the cluster.

```
kubectl expose deployment hello-node --type=LoadBalancer --port=8080
```

### 使用 tool

列出

```
minikube addons list
```

開啟ㄌ

```
minikube addons enable metrics-server

```

```
kubectl get pod,svc -n kube-system
```

```
minikube addons disable metrics-server
```

### clean up

```
kubectl delete service hello-node
kubectl delete deployment hello-node
```

stop cluster

```
minikube stop
```

delete minikube vm

```
# Optional
minikube delete
```

### Using kubectl to Create a Deployment

建立 cluster,透過 deployment 部署,cluster 會把 app 分到某 node,deployment controller 會持續監控 instance,如果 instance 掛了,會被換到其他 node 重啟,你可以透過`kubectl`管理 cluster,

```
The common format of a kubectl command is: kubectl action resource
```

```
kubectl get nodes
```

基本上 pods 跑在獨立私有網路,只有同一 cluster 的其他人可以看到他,透過 kubectl 透過 control plane 跟 node 溝通,包括開啟反向代理
The API server will automatically create an endpoint for each pod, based on the pod name, that is also accessible through the proxy.

```
kubectl proxy
```

他可以幫裡把 cluster 裡的每一個 pod,透過 proxy 建立 endpoint,他是這樣用的
`curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/`
所以如果用查

```
kubectl get pods
```

可以把 pods name 帶入,就可以看到該 pod 相關資訊.

如果不用 proxy 還有啥方法？

### POD 有哪些東東

`When you created a Deployment in Module 2, Kubernetes created a Pod to host your application instance.`

- Shared storage, as Volumes
- Networking, as a unique cluster IP address
- Information about how to run each container, such as the container image version or specific ports to use

```
 For example, a Pod might include both the container with your Node.js app as well as a different container that feeds the data to be published by the Node.js webserver.
```

### node 有哪些東西

每個 Kubernetes 節點至少運行以下組件：

Kubelet：負責在 Kubernetes 控制平面和節點之間溝通；它管理運行在節點上的 Pod 和容器。

容器運行時（例如 Docker）：負責從容器註冊表中拉取容器映像、解壓縮容器並運行應用程序。
https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg

- action: 會有 create,describe,delete 等
  resource 會有 node deployment service

- 開啟對外的 port
  kubectl expose deployment hello-minikube --type=NodePort --port=8080
  連到該服務
  minikube service hello-minikube （會做 tunnel:在 Kubernetes 中，tunnel 是一種用於將流量從本地機器轉發到 Kubernetes 叢集內部的方法。

### service

用 expose 創 service,同時選 type and port.

```
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080

```

擴展 deployment 底下的 replicas of pods

```
kubectl scale deployments/kubernetes-bootcamp --replicas=4
```

看各個 pod 設定

```
kubectl get rs
kubectl get pods -o wide
```

看 deployment 設定

```
kubectl describe deployments/kubernetes-bootcamp
```

看 services 設定

```
kubectl describe services/kubernetes-bootcamp
```

k8s 8080:30170/TCP 前者是 node port 後者是 target port,node port 是 cluster 裡面 pod 的 ip 開的 port,右邊 30170 是本機轉到 cluster 的 30170 port

### Performing a Rolling Update

為了要不斷線 Rolling updates,The new Pods will be scheduled on Nodes with available resources.
簡單說就是要產出新 pod 去做版本轉換,要產幾個ｐｏｄ可以透過設定！

- Rolling updates allow the following actions:

- Promote an application from one environment to another (via container image updates)
- Rollback to previous versions
  Continuous Integration and Continuous Delivery of applications with zero downtime

```
kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2
```

這時候會發現

```
[ec2-user@72slaves ~]$ kubectl get pods
NAME                                   READY   STATUS        RESTARTS      AGE
balanced-56c586bfb9-bwtjj              1/1     Running       2 (27h ago)   27h
hello-minikube-77b6f68484-b2g6t        1/1     Running       2 (27h ago)   27h
kubernetes-bootcamp-5485cc6795-dcxfb   1/1     Terminating   0             139m
kubernetes-bootcamp-5485cc6795-n9zfj   1/1     Terminating   0             113m
kubernetes-bootcamp-7c6644499c-fsffb   1/1     Running       0             12s
kubernetes-bootcamp-7c6644499c-zz9z7   1/1     Running       0             7s
```

rollback 流程

```
kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10
```

```
kubectl get deployments
kubectl get pods
kubectl describe pods 一樣在新版本
以上執行玩會發現還是沒有roll back
pod狀態會是 kubernetes-bootcamp-7589867599-48zvn   0/1     ImagePullBackOff   0             2m54s
```

```
kubectl rollout undo deployments/kubernetes-bootcamp
```

clean

```
kubectl delete deployments/kubernetes-bootcamp services/kubernetes-bootcamp
```

Services have an integrated load-balancer that will distribute network traffic to all Pods of an exposed Deployment.
services 透過一個整合的 load-balancer 對擴展的 pods 做管理

一班 node 掛掉,上面 pod 也會掛,此時，ReplicaSet 可以通過創建新的 Pod 將叢集動態恢復到期望的狀態.舉例:前端 pod 跟後端 pod 要持續互動,如果是透過 ip 去做直連,這樣在 node 掛掉重啟過程中,會遇到麻煩,需要鎖定 ip,因次會多一層抽象的 service 層,前端只要對這個抽象層就不會有多大麻煩！
A Service in Kubernetes is an abstraction which defines a logical set of Pods and a policy by which to access them.

service 有以下幾種 type:

- clusterIP: 會給 service 一個 cluster 的內部 ip,主要用於 cluster 內服務間溝通.
- NodePort: 將服務暴露在集群中每個選定節點上的相同端口。通過使用 "NodeIP:NodePort 的方式，使得服務能夠從叢集外部訪問。
- LoadBalancer: LoadBalancer 類型的 Service 的可用性取決於您運行 Kubernetes 的雲平台是否支援,LoadBalancer 類型的 Service 可以在支援的雲平台上創建一個外部負載均衡器，並為該負載均衡器分配一個固定的外部 IP 地址
- ExternalName:將服務映射到外部名稱字段（例如 foo.bar.example.com），通過返回其值的 CNAME 記錄實現。不會設置任何類型的代理。

service 如何 match 到 pods? using labels and selectors.透過標籤，您可以更輕鬆地管理和操作 Kubernetes 中的對象，

spec 是定義資源配置和行為，它指的是對象（例如 Pod、Deployment、Service 等）的規範（specification）。
對於 Pod 資源，spec 屬性包含了容器的描述，包括映像、埠口、資源需求、環境變量等。對於 Deployment 資源，spec 屬性定義了副本數量、映像、更新策略等。

The set of Pods targeted by a Service is usually determined by a label selector

```
kubectl get - list resources
kubectl describe - show detailed information about a resource
kubectl logs - print the logs from a container in a pod
kubectl exec - execute a command on a container in a pod
```

Kubernetes 叢集內部的服務通常運行在叢集網絡的私有 IP 空間中，無法直接從外部訪問。為了使這些服務能夠從本地機器訪問，您需要建立一個 tunnel，將本地機器的流量轉發到叢集內部。

or
kubectl port-forward service/hello-minikube 7080:8080

### multiple instances

```
To see the ReplicaSet created by the Deployment, run kubectl get rs
```

ClusterIP：內部叢集 IP，僅在叢集內部可訪問。（可以配合 ingress 做內部映射)
NodePort: 某 pod 定義在 node port(節點端口),當前面打到 target port(一個在 cluster 上的 port),會轉到 node port（用於進行調試或查看特定 Pod 的日誌）
LoadBalancer：使用雲提供商的負載平衡器服務，自動提供外部 IP，將流量轉發到服務。
ExternalName：將服務映射到另一個叢集外部的外部域名。

一班都去找 target,極少數會用到 node port.

- 為什麼要多這層設計,docker 就滿明確分為本地端口 port 跟 container 內部 port 而已
  抽象化：目標端口提供了一個抽象層，隱藏了 Pod 內容器的實際端口。這樣，您可以在不修改服務設定的情況下調整容器內部的應用程序端口，提供更靈活的服務配置。

進階 使用 load balance
kubectl create deployment hello-minikube1 --image=kicbase/echo-server:1.0
kubectl expose deployment hello-minikube1 --type=LoadBalancer --port=8080

There are two major categories of services in Kubernetes:

NodePort
LoadBalancer

可以透過帶 flag 方式,帶設定檔進去啟動
minikube start --container-runtime=docker

開啟套件
minikube addons list

A Kubernetes cluster consists of two types of resources:

The Control Plane coordinates the cluster
Nodes are the workers that run applications
透過 control plane 去管理 cluster 跟 node,而 node 會被拿來跑 application,nodes 間溝通是透過 k8s API.

Summary:
Kubernetes cluster
Minikube
Kubernetes is a production-grade, open-source platform that orchestrates the placement (scheduling) and execution of application containers within and across computer clusters.

:::info
參考資料

1. [Kubernetes 101: Pods, Nodes, Containers, and Clusters](https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16)

:::
